#lang sicp
(define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence) (accumulate op initial (cdr sequence)))
    )
)

(define (flatmap proc seq)
    (accumulate append nil (map proc seq))
)

(define (filter predicate sequence)
    (cond ((null? sequence) nil)
          ((predicate (car sequence)) 
            (cons (car sequence) (filter predicate (cdr sequence)))
          )
          (else 
            (filter predicate (cdr sequence))
          )
    )    
)

(define queens `((1 1 1 1) (2 1 1 1) (3 1 1 1) (4 1 1 1) (1 2 1 1) (2 2 1 1) (3 2 1 1) (4 2 1 1) (1 3 1 1) (2 3 1 1) (3 3 1 1) (4 3 1 1) (1 4 1 1) (2 4 1 1) (3 4 1 1) (4 4 1 1) (1 1 2 1) (2 1 2 1) (3 1 2 1) (4 1 2 1) (1 2 2 1) (2 2 2 1) (3 2 2 1) (4 2 2 1) (1 3 2 1) (2 3 2 1) (3 3 2 1) (4 3 2 1) (1 4 2 1) (2 4 2 1) (3 4 2 1) (4 4 2 1) (1 1 3 1) (2 1 3 1) (3 1 3 1) (4 1 3 1) (1 2 3 1) (2 2 3 1) (3 2 3 1) (4 2 3 1) (1 3 3 1) (2 3 3 1) (3 3 3 1) (4 3 3 1) (1 4 3 1) (2 4 3 1) (3 4 3 1) (4 4 3 1) (1 1 4 1) (2 1 4 1) (3 1 4 1) (4 1 4 1) (1 2 4 1) (2 2 4 1) (3 2 4 1) (4 2 4 1) (1 3 4 1) (2 3 4 1) (3 3 4 1) (4 3 4 1) (1 4 4 1) (2 4 4 1) (3 4 4 1) (4 4 4 1) (1 1 1 2) (2 1 1 2) (3 1 1 2) (4 1 1 2) (1 2 1 2) (2 2 1 2) (3 2 1 2) (4 2 1 2) (1 3 1 2) (2 3 1 2) (3 3 1 2) (4 3 1 2) (1 4 1 2) (2 4 1 2) (3 4 1 2) (4 4 1 2) (1 1 2 2) (2 1 2 2) (3 1 2 2) (4 1 2 2) (1 2 2 2) (2 2 2 2) (3 2 2 2) (4 2 2 2) (1 3 2 2) (2 3 2 2) (3 3 2 2) (4 3 2 2) (1 4 2 2) (2 4 2 2) (3 4 2 2) (4 4 2 2) (1 1 3 2) (2 1 3 2) (3 1 3 2) (4 1 3 2) (1 2 3 2) (2 2 3 2) (3 2 3 2) (4 2 3 2) (1 3 3 2) (2 3 3 2) (3 3 3 2) (4 3 3 2) (1 4 3 2) (2 4 3 2) (3 4 3 2) (4 4 3 2) (1 1 4 2) (2 1 4 2) (3 1 4 2) (4 1 4 2) (1 2 4 2) (2 2 4 2) (3 2 4 2) (4 2 4 2) (1 3 4 2) (2 3 4 2) (3 3 4 2) (4 3 4 2) (1 4 4 2) (2 4 4 2) (3 4 4 2) (4 4 4 2) (1 1 1 3) (2 1 1 3) (3 1 1 3) (4 1 1 3) (1 2 1 3) (2 2 1 3) (3 2 1 3) (4 2 1 3) (1 3 1 3) (2 3 1 3) (3 3 1 3) (4 3 1 3) (1 4 1 3) (2 4 1 3) (3 4 1 3) (4 4 1 3) (1 1 2 3) (2 1 2 3) (3 1 2 3) (4 1 2 3) (1 2 2 3) (2 2 2 3) (3 2 2 3) (4 2 2 3) (1 3 2 3) (2 3 2 3) (3 3 2 3) (4 3 2 3) (1 4 2 3) (2 4 2 3) (3 4 2 3) (4 4 2 3) (1 1 3 3) (2 1 3 3) (3 1 3 3) (4 1 3 3) (1 2 3 3) (2 2 3 3) (3 2 3 3) (4 2 3 3) (1 3 3 3) (2 3 3 3) (3 3 3 3) (4 3 3 3) (1 4 3 3) (2 4 3 3) (3 4 3 3) (4 4 3 3) (1 1 4 3) (2 1 4 3) (3 1 4 3) (4 1 4 3) (1 2 4 3) (2 2 4 3) (3 2 4 3) (4 2 4 3) (1 3 4 3) (2 3 4 3) (3 3 4 3) (4 3 4 3) (1 4 4 3) (2 4 4 3) (3 4 4 3) (4 4 4 3) (1 1 1 4) (2 1 1 4) (3 1 1 4) (4 1 1 4) (1 2 1 4) (2 2 1 4) (3 2 1 4) (4 2 1 4) (1 3 1 4) (2 3 1 4) (3 3 1 4) (4 3 1 4) (1 4 1 4) (2 4 1 4) (3 4 1 4) (4 4 1 4) (1 1 2 4) (2 1 2 4) (3 1 2 4) (4 1 2 4) (1 2 2 4) (2 2 2 4) (3 2 2 4) (4 2 2 4) (1 3 2 4) (2 3 2 4) (3 3 2 4) (4 3 2 4) (1 4 2 4) (2 4 2 4) (3 4 2 4) (4 4 2 4) (1 1 3 4) (2 1 3 4) (3 1 3 4) (4 1 3 4) (1 2 3 4) (2 2 3 4) (3 2 3 4) (4 2 3 4) (1 3 3 4) (2 3 3 4) (3 3 3 4) (4 3 3 4) (1 4 3 4) (2 4 3 4) (3 4 3 4) (4 4 3 4) (1 1 4 4) (2 1 4 4) (3 1 4 4) (4 1 4 4) (1 2 4 4) (2 2 4 4) (3 2 4 4) (4 2 4 4) (1 3 4 4) (2 3 4 4) (3 3 4 4) (4 3 4 4) (1 4 4 4) (2 4 4 4) (3 4 4 4) (4 4 4 4)))

(define (safe? queen-pos)
    (define (check-next queen-p positions move)
        (if (null? positions)
            #t
            (let ((queen-row (car positions)))
                (if (or (= queen-row queen-p)
                        (= (+ queen-row move) queen-p)
                        (= (- queen-row move) queen-p)
                    )
                    #f
                    (check-next queen-p (cdr positions) (inc move))
                )
            )
        )
    )
    (check-next (car queen-pos) (cdr queen-pos) 1)
)

; (filter safe? queens)
(safe? `(2 4 1 3))


